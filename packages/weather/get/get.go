package main

import (
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"time"
)

type Input struct {
	Lat string `json:"lat"`
	Lon string `json:"lon"`
}

type NominatimRes struct {
	PlaceID     int                    `json:"place_id"`
	Licence     string                 `json:"licence"`
	OsmType     string                 `json:"osm_type"`
	OsmID       int                    `json:"osm_id"`
	Lat         string                 `json:"lat"`
	Lon         string                 `json:"lon"`
	DisplayName string                 `json:"display_name"`
	Address     map[string]interface{} `json:"address"`
	Boundingbox []string               `json:"boundingbox"`
}

type AutoGenerated struct {
	WeatherForecasts []struct {
		Location struct {
			Lat float64 `json:"lat"`
			Lon float64 `json:"lon"`
		} `json:"location"`
		Forecasts []struct {
			Time time.Time `json:"time"`
			Data struct {
				Cloudhigh int     `json:"cloudhigh"`
				Cloudlow  int     `json:"cloudlow"`
				Cloudmed  int     `json:"cloudmed"`
				Cond      int     `json:"cond"`
				Rain      int     `json:"rain"`
				Rh        float64 `json:"rh"`
				Slp       float64 `json:"slp"`
				Tc        float64 `json:"tc"`
				Wd10M     float64 `json:"wd10m"`
				Ws10M     float64 `json:"ws10m"`
			} `json:"data"`
		} `json:"forecasts"`
	} `json:"WeatherForecasts"`
}

type Response struct {
	StatusCode int               `json:"statusCode,omitempty"`
	Headers    map[string]string `json:"headers,omitempty"`
	Body       *PackedResponse   `json:"body,omitempty"`
}

type PackedResponse struct {
	Data PrettyResponse `json:"data"`
}

type PrettyResponse struct {
	Temperature      float64   `json:"temperature"`
	RelativeHumidity float64   `json:"relative_humidity"`
	RainPercentage   int       `json:"rain_percentage"`
	Condition        string    `json:"condition"`
	Time             time.Time `json:"timestamp"`
	WindSpeed        float64   `json:"wind_speed"`
	WindDirection    float64   `json:"wind_direction"`
	Location         struct {
		Lat         float64                `json:"lat"`
		Lon         float64                `json:"lon"`
		DisplayName string                 `json:"display_name"`
		Address     map[string]interface{} `json:"address"`
	}
}

func Main(ipt Input) (*Response, error) {
	var response Response
	/**
	Load Environment
	Disabled for FaaS
	*/
	//error := godotenv.Load(".env")
	//if error != nil {
	//	response.Body = error.Error()
	//	response.StatusCode = http.StatusInternalServerError
	//	panic(error)
	//}

	/**
	Initialize HTTP Client
	*/
	client := &http.Client{}

	/**
	Begin to URL Parsing and Add Query
	*/
	urls, err := url.Parse(os.Getenv("TMD_API_ENDPOINT") + "/forecast/location/hourly/at")
	q := urls.Query()
	q.Add("lat", ipt.Lat)
	q.Add("lon", ipt.Lon)
	q.Add("fields", "tc,rh,slp,rain,ws10m,wd10m,cloudlow,cloudmed,cloudhigh,cond")
	urls.RawQuery = q.Encode()

	/**
	Begin to Nominatim OpenStreetMap API
	*/
	nominatim, err := url.Parse(os.Getenv("NOMINATIM_API_ENDPOINT") + "/reverse")
	query := urls.Query()
	query.Add("lat", ipt.Lat)
	query.Add("lon", ipt.Lon)
	query.Add("format", "json")
	nominatim.RawQuery = query.Encode()
	nominatimReq, err := http.NewRequest("GET", nominatim.String(), nil)
	nominatimRes, err := client.Do(nominatimReq)
	nominatimFinal, err := io.ReadAll(nominatimRes.Body)
	var nominatimF NominatimRes
	if err := json.Unmarshal(nominatimFinal, &nominatimF); err != nil {
		response.Body = nil
		response.StatusCode = http.StatusInternalServerError
		return &Response{
			Body:       response.Body,
			StatusCode: response.StatusCode,
		}, nil
	}

	/**
	Begin HTTP Request
	*/
	reqs, err := http.NewRequest("GET", urls.String(), nil)
	reqs.Header.Add("Authorization", "Bearer "+os.Getenv("TMD_API_KEY"))
	resp, err := client.Do(reqs)
	if err != nil {
		response.Body = nil
		response.StatusCode = http.StatusInternalServerError
		return &Response{
			Body:       response.Body,
			StatusCode: response.StatusCode,
		}, nil
	}

	/**
	Parsing Body by IOUtil
	*/
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		response.Body = nil
		response.StatusCode = http.StatusInternalServerError
		return &Response{
			Body:       response.Body,
			StatusCode: response.StatusCode,
		}, nil
	}

	/**
	Unmarshal Result to JSON and Add Struct to According to Result Body
	*/
	var result AutoGenerated
	if err := json.Unmarshal(body, &result); err != nil { // Parse []byte to go struct pointer
		response.Body = nil
		response.StatusCode = http.StatusInternalServerError
		return &Response{
			Body:       response.Body,
			StatusCode: response.StatusCode,
		}, nil
	}

	var prettyResponse PrettyResponse
	prettyResponse.Location.Lat, _ = strconv.ParseFloat(ipt.Lat, 64)
	prettyResponse.Location.Lon, _ = strconv.ParseFloat(ipt.Lon, 64)
	prettyResponse.Time = result.WeatherForecasts[0].Forecasts[0].Time
	prettyResponse.Condition = []string{"CLEAR", "PARTLY_CLOUDY", "CLOUDY", "OVERCAST", "LIGHT_RAIN", "MODERATE_RAIN", "HEAVY_RAIN", "THUNDERSTORM", "VERY_COLD", "COLD", "COOL", "VERY_HOT"}[result.WeatherForecasts[0].Forecasts[0].Data.Cond+1]
	prettyResponse.Temperature = result.WeatherForecasts[0].Forecasts[0].Data.Tc
	prettyResponse.Location.Address = nominatimF.Address
	prettyResponse.Location.DisplayName = nominatimF.DisplayName
	prettyResponse.RainPercentage = result.WeatherForecasts[0].Forecasts[0].Data.Rain
	prettyResponse.RelativeHumidity = result.WeatherForecasts[0].Forecasts[0].Data.Rh
	prettyResponse.WindSpeed = result.WeatherForecasts[0].Forecasts[0].Data.Ws10M
	prettyResponse.WindDirection = result.WeatherForecasts[0].Forecasts[0].Data.Wd10M

	rs := &PackedResponse{
		Data: prettyResponse,
	}
	response.Body = rs
	response.StatusCode = http.StatusOK

	return &Response{
		Body:       response.Body,
		StatusCode: response.StatusCode,
	}, nil
}
